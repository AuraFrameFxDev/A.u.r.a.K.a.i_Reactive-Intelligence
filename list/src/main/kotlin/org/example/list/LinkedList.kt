/*
 * This source file was generated by the Gradle 'init' task
 */
package dev.aurakai.auraframefx.list

class LinkedList : MutableList<String> {
    private var head: Node? = null

    private data class Node(val data: String, var next: Node? = null)

    override val size: Int
        get() = calculateSize()

    private fun calculateSize(): Int {
        var size = 0
        var it = head
        while (it != null) {
            size++
            it = it.next
        }
        return size
    }

    override fun isEmpty(): Boolean = head == null

    override fun contains(element: String): Boolean {
        var it = head
        while (it != null) {
            if (it.data == element) return true
            it = it.next
        }
        return false
    }

    override fun containsAll(elements: Collection<String>): Boolean {
        for (e in elements) {
            if (!contains(e)) return false
        }
        return true
    }

    override fun get(index: Int): String {
        val node = getNodeAt(index) ?: throw IndexOutOfBoundsException("Index: $index")
        return node.data
    }

    private fun getNodeAt(index: Int): Node? {
        if (index < 0) return null
        var it = head
        for (i in 0 until index) {
            it = it?.next ?: return null
        }
        return it
    }

    override fun indexOf(element: String): Int {
        var index = 0
        var it = head
        while (it != null) {
            if (it.data == element) return index
            index++
            it = it.next
        }
        return -1
    }

    override fun lastIndexOf(element: String): Int {
        var lastIndex = -1
        var index = 0
        var it = head
        while (it != null) {
            if (it.data == element) lastIndex = index
            index++
            it = it.next
        }
        return lastIndex
    }

    override fun iterator(): Iterator<String> = object : Iterator<String> {
        private var current = head

        override fun hasNext() = current != null

        override fun next(): String {
            val data = current?.data ?: throw NoSuchElementException()
            current = current?.next
            return data
        }
    }

    override fun listIterator(): ListIterator<String> = listIterator(0)

    override fun listIterator(index: Int): ListIterator<String> {
        if (index < 0 || index > size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        val snapshot = this.toList()
        return object : ListIterator<String> {
            private var pos = index

            override fun hasNext() = pos < snapshot.size

            override fun next(): String {
                if (!hasNext()) throw NoSuchElementException()
                return snapshot[pos++]
            }

            override fun hasPrevious() = pos > 0

            override fun previous(): String {
                if (!hasPrevious()) throw NoSuchElementException()
                return snapshot[--pos]
            }

            override fun nextIndex() = pos

            override fun previousIndex() = pos - 1
        }
    }

    override fun subList(fromIndex: Int, toIndex: Int): List<String> {
        if (fromIndex < 0 || toIndex < fromIndex || toIndex > size) {
            throw IndexOutOfBoundsException("fromIndex=$fromIndex, toIndex=$toIndex, size=$size")
        }
        val result = ArrayList<String>(toIndex - fromIndex)
        var i = 0
        var it = head
        while (i < toIndex && it != null) {
            if (i >= fromIndex) result.add(it.data)
            it = it.next
            i++
        }
        return result
    }

    override fun add(element: String): Boolean {
        val newNode = Node(element)
        val tail = tail(head)
        if (tail == null) {
            head = newNode
        } else {
            tail.next = newNode
        }
        return true
    }

    override fun add(index: Int, element: String) {
        if (index < 0 || index > size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        val newNode = Node(element)
        if (index == 0) {
            newNode.next = head
            head = newNode
        } else {
            val prev = getNodeAt(index - 1)
            newNode.next = prev?.next
            prev?.next = newNode
        }
    }

    override fun addAll(elements: Collection<String>): Boolean {
        for (e in elements) {
            add(e)
        }
        return elements.isNotEmpty()
    }

    override fun addAll(index: Int, elements: Collection<String>): Boolean {
        if (index < 0 || index > size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        var currentIndex = index
        for (e in elements) {
            add(currentIndex, e)
            currentIndex++
        }
        return elements.isNotEmpty()
    }

    override fun clear() {
        head = null
    }

    override fun remove(element: String): Boolean {
        var previous: Node? = null
        var it = head
        while (it != null) {
            if (it.data == element) {
                if (previous == null) {
                    head = it.next
                } else {
                    previous.next = it.next
                }
                return true
            }
            previous = it
            it = it.next
        }
        return false
    }

    override fun removeAt(index: Int): String {
        if (index < 0 || index >= size) throw IndexOutOfBoundsException("Index: $index, Size: $size")
        if (index == 0) {
            val data = head?.data ?: throw IndexOutOfBoundsException()
            head = head?.next
            return data
        } else {
            val prev = getNodeAt(index - 1) ?: throw IndexOutOfBoundsException()
            val node = prev.next ?: throw IndexOutOfBoundsException()
            prev.next = node.next
            return node.data
        }
    }

    override fun removeAll(elements: Collection<String>): Boolean {
        var changed = false
        for (e in elements) {
            if (remove(e)) changed = true
        }
        return changed
    }

    override fun retainAll(elements: Collection<String>): Boolean {
        var changed = false
        val toRemove = mutableListOf<String>()
        for (e in this) {
            if (e !in elements) toRemove.add(e)
        }
        for (e in toRemove) {
            remove(e)
            changed = true
        }
        return changed
    }

    override fun set(index: Int, element: String): String {
        val node = getNodeAt(index) ?: throw IndexOutOfBoundsException("Index: $index")
        val old = node.data
        node.data = element
        return old
    }

    private fun tail(head: Node?): Node? {
        var it = head
        while (it?.next != null) {
            it = it.next
        }
        return it
    }
}
